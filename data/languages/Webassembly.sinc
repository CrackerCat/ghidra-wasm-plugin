# sleigh include file for Skeleton language instructions

define token opcode (8)
	opc = (0,7)
;

define token opcode2 (8)
	opc2 = (0,7)
;

define token byteval (8)
	bytev = (0,7)
;

define token I32 (32)
	f32 = (0,31)
;

define token I64 (64)
    f64 = (0,63)
;

################################################################
# Macros
################################################################

# These pcodeop's have NOP semantics, they just signal to the analyzer to modify the controlStack and valueStack
define pcodeop pushCallOther;
define pcodeop popCallOther;
define pcodeop beginLoopCallOther;
define pcodeop beginBlockCallOther;
define pcodeop endCallOther;

# These pcodeop's do not have NOP semantics, they are dynamically injected into by PcodeInjectLibraryWasm
define pcodeop brCallOther;
define pcodeop callCallOther;
define pcodeop ifCallOther;
define pcodeop elseCallOther;
define pcodeop returnCallOther;
define pcodeop callIndirectCallOther;
define pcodeop brTableCallOther;

macro push32(val32) {
	pushCallOther(32:4);
	val64:8 = zext(val32);
	SP = SP - 8;
	*:8 SP = val64; 
}

macro pop32(ret32) {
	popCallOther(32:4);
	ret32 = *:4 SP;
	SP = SP + 8; 
}

macro push64(val64) {
	pushCallOther(64:4);
	SP = SP - 8;
	*:8 SP = val64; 
}

macro pop64(ret64) {
	popCallOther(64:4);
	ret64 = *:8 SP;
	SP = SP + 8; 
}

################################################################

define pcodeop halt_trap;
define pcodeop popcnt;
define pcodeop clz;
define pcodeop ctz;
define pcodeop br_if;
define pcodeop rotl;
define pcodeop rotr;
# TODO: define some of these in terms of a more generic "memcpy"/"memset" operation
define pcodeop table_init;
define pcodeop elem_drop;
define pcodeop table_copy;
define pcodeop table_grow;
define pcodeop table_size;
define pcodeop table_fill;
define pcodeop memory_size;
define pcodeop memory_grow;
define pcodeop memory_init;
define pcodeop data_drop;
define pcodeop memory_copy;
define pcodeop memory_fill;

define pcodeop funcref;

@include "Leb128.sinc"

funcidx: ULeb128 is ULeb128 {
	export ULeb128;
}

localidx: ULeb128 is ULeb128 {
	export ULeb128;
}

globalidx: ULeb128 is ULeb128 {
	export ULeb128;
}

typeidx: ULeb128 is ULeb128 {
	export ULeb128;
}

elemidx: ULeb128 is ULeb128 {
	export ULeb128;
}

tableidx: ULeb128 is ULeb128 {
	export ULeb128;
}

tableidx2: ULeb128 is ULeb128 {
	export ULeb128;
}

dataidx: ULeb128 is ULeb128 {
	export ULeb128;
}

memidx: ULeb128 is ULeb128 {
	export ULeb128;
}

memidx2: ULeb128 is ULeb128 {
	export ULeb128;
}

reftype: "reftype="^bytev is bytev {
	val:1 = bytev;
	export val;
}

macro trap() {
<trap_loop>
	halt_trap();
	goto <trap_loop>;
}

################################################################

indent: "" is indent_lvl=0 {}
indent: " . "^indent is indent [ indent_lvl = indent_lvl - 1; ]{}

# This outputs one less indentation than indent, use this when the indent_lvl is increased by the current instruction
inc_indent: "" is indent_lvl=1 | indent_lvl=0 {}
inc_indent: " . "^inc_indent is inc_indent [ indent_lvl = indent_lvl-1; ]{}

@define INC_INDENT "inc_indent [ indent_lvl = indent_lvl + 1; globalset(inst_next, indent_lvl); ]"

## Control instructions
:""^indent^"unreachable" is opc=0x00; indent {
	trap();
}

:""^indent^"nop" is opc=0x01; indent {}

:""^inc_indent^"block" "blocktype="^ULeb128 is opc=0x02; ULeb128; $(INC_INDENT) {
	beginBlockCallOther();
}
:""^inc_indent^"loop" "blocktype="^ULeb128 is opc=0x03; ULeb128; $(INC_INDENT) {
	beginLoopCallOther();
}
:""^inc_indent^"if" "blocktype="^ULeb128 is opc=0x04; ULeb128; $(INC_INDENT) {
	val:4 = 0;
	pop32(val);
	if(val != 0) goto inst_next;
	ifCallOther();
}
:""^inc_indent^"else" is opc=0x05; inc_indent {
	elseCallOther();
}

:""^indent^"end" is opc=0x0b; indent_lvl=0; indent {
	returnCallOther();
	# This is a redundant return statement, but it lets the disassembler know to stop disassembling
	return [LR];
}
:""^indent^"end" is opc=0x0b; indent [ indent_lvl = indent_lvl - 1; globalset(inst_next, indent_lvl); ] {
	endCallOther();
}

:""^indent^"br" ULeb128 is opc=0x0c; ULeb128; indent {
	brCallOther();
}
:""^indent^"br_if" ULeb128 is opc=0x0d; ULeb128; indent {
	val:4 = 0;
	pop32(val);
	if(val == 0) goto inst_next;
	brCallOther();
}

@include "br_table.sinc"

:""^indent^"return" is opc=0x0f; indent {
	returnCallOther();
}
:""^indent^"call" ULeb128 is opc=0x10; ULeb128; indent {
	callCallOther();
}
:""^indent^"call_indirect" typeidx tableidx is opc=0x11; typeidx; tableidx; indent {
	callIndirectCallOther();
}

## Reference Instructions
:""^indent^"ref.null" reftype is opc=0xd0; reftype; indent {
	val:8 = 0;
	push64(val);
}
:""^indent^"ref.is_null" is opc=0xd1; indent {
	val:8 = 0;
	pop64(val);
	res:4 = zext(val == 0);
	push32(res);
}
:""^indent^"ref.func" funcidx is opc=0xd2; funcidx; indent {
	# TODO: make an (artificial) table of functions so we can statically resolve funcrefs
	val:8 = funcref(funcidx);
	push64(val);
}

## Parametric Instructions
:""^indent^"drop" is opc=0x1a; indent {
	val:8 = 0;
	pop64(val);
}
:""^indent^"select" is opc=0x1b; indent {
	cond:4 = 0;
	pop32(cond);
	val1:8 = 0;
	val2:8 = 0;
	pop64(val2);
	pop64(val1);
	res:8 = 0;
	if (cond != 0) goto <true>;
	res = val1;
	goto <finish>;
<true>
	res = val2;
<finish>
	push64(res);
}
# In the current version of WASM, only one type index is permitted in select t*.
# This is functionally identical to regular select.
:""^indent^"select" typeidx is opc=0x1c; opc2=0x01; typeidx; indent {
	cond:4 = 0;
	pop32(cond);
	val1:8 = 0;
	val2:8 = 0;
	pop64(val2);
	pop64(val1);
	res:8 = 0;
	if (cond != 0) goto <true>;
	res = val1;
	goto <finish>;
<true>
	res = val2;
<finish>
	push64(res);
}

## Variable Instructions
# TODO: these need to be callOther to process the size of the local correctly
:""^indent^"local.get" localidx is opc=0x20; localidx; indent {
	val:8 = *[register] (localidx:2 * 8);
	push64(val);
}
:""^indent^"local.set" localidx is opc=0x21; localidx; indent {
	val:8 = 0;
	pop64(val);
	*[register] (localidx:2 * 8) = val;
}
:""^indent^"local.tee" localidx is opc=0x22; localidx; indent {
	val:8 = 0;
	pop64(val);
	*[register] (localidx:2 * 8) = val;
	push64(val);
}
:""^indent^"global.get" globalidx is opc=0x23; globalidx; indent {
	val:8 = *[global] (globalidx:4 * 8);
	push64(val);
}
:""^indent^"global.set" globalidx is opc=0x24; globalidx; indent {
	val:8 = 0;
	pop64(val);
	*[global] (globalidx:4 * 8) = val;
}

## Table Instructions
:""^indent^"table.get" tableidx is opc=0x25; tableidx; indent {
	idx:4 = 0;
	pop32(idx);
	sidx:8 = sext(idx);
	val:8 = *[table] ((tableidx:8 << 32) + sidx * 8);
	push64(val);
}

:""^indent^"table.set" tableidx is opc=0x26; tableidx; indent {
	val:8 = 0;
	pop64(val);
	idx:4 = 0;
	pop32(idx);
	sidx:8 = sext(idx);
	*[table] ((tableidx:8 << 32) + sidx * 8) = val;
}

:""^indent^"table.init" elemidx tableidx is opc=0xfc; opc2=0x0c; elemidx; tableidx; indent {
	count:4 = 0;
	pop32(count);
	src:4 = 0;
	pop32(src);
	dst:4 = 0;
	pop32(dst);
	table_init(elemidx:4, tableidx:4, count, src, dst);
}

:""^indent^"elem.drop" elemidx is opc=0xfc; opc2=0x0d; elemidx; indent {
	elem_drop(elemidx:4);
}

:""^indent^"table.copy" tableidx tableidx2 is opc=0xfc; opc2=0x0e; tableidx; tableidx2; indent {
	count:4 = 0;
	pop32(count);
	src:4 = 0;
	pop32(src);
	dst:4 = 0;
	pop32(dst);
	table_copy(tableidx:4, tableidx2:4, count, src, dst);
}

:""^indent^"table.grow" tableidx is opc=0xfc; opc2=0x0f; tableidx; indent {
	new_sz:4 = 0;
	pop32(new_sz);
	val:4 = table_grow(tableidx:4, new_sz);
	push32(val);
}

:""^indent^"table.size" tableidx is opc=0xfc; opc2=0x10; tableidx; indent {
	val:4 = table_size(tableidx:4);
	push32(val);
}

:""^indent^"table.fill" tableidx is opc=0xfc; opc2=0x11; tableidx; indent {
	count:4 = 0;
	pop32(count);
	val:8 = 0;
	pop64(val);
	dst:4 = 0;
	pop32(dst);
	table_fill(tableidx:4, count, val, dst);
}


## Memory Instructions
:""^indent^"memory.size" memidx is opc=0x3f; memidx; indent {
	val:4 = memory_size(memidx:4);
	push32(val);
}

:""^indent^"memory.grow" memidx is opc=0x40; memidx; indent {
	new_sz:4 = 0;
	pop32(new_sz);
	val:4 = memory_grow(memidx:4, new_sz);
	push32(val);
}

:""^indent^"memory.init" dataidx memidx is opc=0xfc; opc2=0x08; dataidx; memidx; indent {
	count:4 = 0;
	pop32(count);
	src:4 = 0;
	pop32(src);
	dst:4 = 0;
	pop32(dst);
	memory_init(dataidx, memidx:4, count, src, dst);
}

:""^indent^"data.drop" dataidx is opc=0xfc; opc2=0x09; dataidx; indent {
	data_drop(dataidx);
}

:""^indent^"memory.copy" memidx memidx2 is opc=0xfc; opc2=0x0a; memidx; memidx2; indent {
	count:4 = 0;
	pop32(count);
	src:4 = 0;
	pop32(src);
	dst:4 = 0;
	pop32(dst);
	memory_copy(memidx:4, memidx2:4, count, src, dst);
}

:""^indent^"memory.fill" memidx is opc=0xfc; opc2=0x0b; memidx; indent {
	count:4 = 0;
	pop32(count);
	val:4 = 0;
	pop32(val);
	dst:4 = 0;
	pop32(dst);
	memory_fill(memidx:4, count, val, dst);
}

## Numeric Instructions: const
:""^indent^"i32.const" SLeb128 is opc=0x41; SLeb128; indent {
	val:4 = SLeb128:4;
	push32(val);
}

:""^indent^"i64.const" SLeb128 is opc=0x42; SLeb128; indent {
	val:8 = SLeb128:8;
	push64(val);
}

:""^indent^"f32.const" f32 is opc=0x43; f32; indent {
	val:4 = f32:4;
	push32(val);
}

:""^indent^"f64.const" f64 is opc=0x44; f64; indent {
	val:8 = f64:8;
	push64(val);
}

@include "BasicOps.sinc"
