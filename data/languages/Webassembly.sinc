# sleigh include file for Skeleton language instructions

define token opbyte (8)
	opc = (0, 7)
	opc2 = (0, 7)
	valtype = (0, 7)
	bytev = (0, 7)

	topbit = (7, 7)
	v0 = (0, 6)
	v1 = (0, 6)
	v2 = (0, 6)
	v3 = (0, 6)
	v4 = (0, 6)
	v5 = (0, 6)
	v6 = (0, 6)
	v7 = (0, 6)
	v8 = (0, 6)
	v9 = (0, 6)
;

define token I32 (32)
	f32 = (0,31)
;

define token I64 (64)
	f64 = (0,63)
;

################################################################
# Macros
################################################################

macro push32(val) {
	val32:4 = zext(val);
	SP = SP - 8;
	*:4 SP = val32;
}

macro pop32(ret32) {
	ret32 = *:4 SP;
	SP = SP + 8; 
}

macro push64(val) {
	val64:8 = zext(val);
	SP = SP - 8;
	*:8 SP = val64; 
}

macro pop64(ret64) {
	ret64 = *:8 SP;
	SP = SP + 8; 
}

################################################################

define pcodeop popCallOther;
define pcodeop pushCallOther;

define pcodeop halt_trap;
define pcodeop popcnt;
define pcodeop clz;
define pcodeop ctz;
# TODO: define some of these in terms of a more generic "memcpy"/"memset" operation
define pcodeop table_init;
define pcodeop elem_drop;
define pcodeop table_copy;
define pcodeop table_grow;
define pcodeop table_size;
define pcodeop table_fill;
define pcodeop memory_size;
define pcodeop memory_grow;
define pcodeop memory_init;
define pcodeop data_drop;
define pcodeop memory_copy;
define pcodeop memory_fill;

@include "Leb128.sinc"

# This is a silly hack because I couldn't work out how to use Leb128 itself
# in the disassembly actions section of another constructor...
@define SYMBOL local4
@define DEST_EXPR "0x1000000000 + 8 * "
@define EXPORT_EXPR "export *[register]:4 dest;"
@include "Leb128_u32.sinc"

@define SYMBOL local8
@define DEST_EXPR "0x1000000000 + 8 * "
@define EXPORT_EXPR "export *[register]:8 dest;"
@include "Leb128_u32.sinc"

@define SYMBOL global4
@define DEST_EXPR "8 * "
@define EXPORT_EXPR "export *[global]:4 dest;"
@include "Leb128_u32.sinc"

@define SYMBOL global8
@define DEST_EXPR "8 * "
@define EXPORT_EXPR "export *[global]:8 dest;"
@include "Leb128_u32.sinc"

@define SYMBOL tableref
@define DEST_EXPR "(1<<32) * "
@define EXPORT_EXPR "export *[table]:8 dest;"
@include "Leb128_u32.sinc"

br_target: ctx_br_target is ctx_br_target {
	export *[ram]:4 ctx_br_target;
}

funcidx: ULeb128 is ULeb128 {
	export ULeb128;
}

typeidx: ULeb128 is ULeb128 {
	export ULeb128;
}

elemidx: ULeb128 is ULeb128 {
	export ULeb128;
}

tableidx: ULeb128 is ULeb128 {
	export ULeb128;
}

tableidx2: ULeb128 is ULeb128 {
	export ULeb128;
}

dataidx: ULeb128 is ULeb128 {
	export ULeb128;
}

memidx: ULeb128 is ULeb128 {
	export ULeb128;
}

memidx2: ULeb128 is ULeb128 {
	export ULeb128;
}

reftype: "reftype="^bytev is bytev {
	val:1 = bytev;
	export val;
}

macro trap() {
<trap_loop>
	halt_trap();
	goto <trap_loop>;
}

macro doBranch(ctx_sp_adjust, br_target) {
	popCallOther(&t0);
	SP = SP + ctx_sp_adjust * 8;
	pushCallOther(&t0);
	goto br_target;
}

################################################################

indent: "" is ctx_indent=0 & ctx_is_case=0 {}
indent: "  "^indent is indent & ctx_is_case=0 [ ctx_indent = ctx_indent - 1; ] {}

# This outputs one less indentation than indent, use this when the ctx_indent is decreased by the current instruction
dec_indent: "" is (ctx_indent=1 | ctx_indent=0) & ctx_is_case=0 {}
dec_indent: "  "^dec_indent is dec_indent & ctx_is_case=0 [ ctx_indent = ctx_indent-1; ]{}

case_indent: "" is ctx_indent=0 & ctx_is_case=1 {}
case_indent: "  "^case_indent is case_indent & ctx_is_case=1 [ ctx_indent = ctx_indent - 1; ] {}

## Control instructions
:""^indent^"unreachable" is opc=0x00; indent {
	trap();
}

:""^indent^"nop" is opc=0x01; indent {
}

:""^indent^"block" "blocktype="^ULeb128 is opc=0x02; ULeb128; indent {
}
:""^indent^"loop" "blocktype="^ULeb128 is opc=0x03; ULeb128; indent {
}
:""^indent^"if" "blocktype="^ULeb128 is opc=0x04; ULeb128; ctx_sp_adjust; br_target; indent {
	local val:4;
	pop32(val);
	if(val != 0) goto inst_next;
	doBranch(ctx_sp_adjust, br_target);
}
:""^indent^"else" is opc=0x05; ctx_sp_adjust; br_target; indent {
	doBranch(ctx_sp_adjust, br_target);
}

:end is opc=0x0b; ctx_indent=0; indent {
	popCallOther(&o0);
	return [LR];
}
:""^dec_indent^"end" is opc=0x0b; dec_indent {
}

:""^indent^"br" br_target is opc=0x0c; ULeb128; ctx_sp_adjust; br_target; indent {
	doBranch(ctx_sp_adjust, br_target);
}
:""^indent^"br_if" br_target is opc=0x0d; ULeb128; ctx_sp_adjust; br_target; indent {
	local val:4;
	pop32(val);
	if(val == 0) goto inst_next;
	doBranch(ctx_sp_adjust, br_target);
}

:""^case_indent^".case" ctx_case_index br_target is ULeb128; ctx_sp_adjust; br_target; ctx_case_index; ctx_is_default=0; case_indent {
	if(BRTableInput != ctx_case_index) goto inst_next;
	doBranch(ctx_sp_adjust, br_target);
}

:""^case_indent^".default" br_target is ULeb128; ctx_sp_adjust; br_target; ctx_is_default=1; case_indent {
	doBranch(ctx_sp_adjust, br_target);
}

:""^indent^"br_table" is opc=0x0e; ULeb128; indent {
	pop32(BRTableInput);
}

:""^indent^"return" is opc=0x0f; ctx_sp_adjust; indent {
	popCallOther(&o0);
	SP = SP + ctx_sp_adjust * 8;
	return [LR];
}
:""^indent^"call" br_target is opc=0x10; ULeb128; br_target; indent {
	popCallOther(&i0);
	call br_target;
	pushCallOther(&o0);
}
:""^indent^"call_indirect" "type="^typeidx tableref is opc=0x11; typeidx; tableref; indent {
	local idx:4;
	pop32(idx);
	addr:8 = &tableref + sext(idx) * 8;
	val:8 = *[table] addr;
	popCallOther(&i0);
	call [val];
	pushCallOther(&o0);
}

## Reference Instructions
:""^indent^"ref.null" reftype is opc=0xd0; reftype; indent {
	val:8 = 0;
	push64(val);
}
:""^indent^"ref.is_null" is opc=0xd1; indent {
	local val:8;
	pop64(val);
	res:4 = zext(val == 0);
	push32(res);
}
:""^indent^"ref.func" funcidx is opc=0xd2; funcidx; br_target; indent {
	val:8 = &br_target;
	push64(val);
}

## Parametric Instructions
:""^indent^"drop" is opc=0x1a; indent {
	local val:8;
	pop64(val);
}

macro select32() {
	local cond:4;
	pop32(cond);
	local val1:4;
	local val2:4;
	pop32(val2);
	pop32(val1);
	if (cond != 0) goto <true>;
	push32(val2);
	goto inst_next;
<true>
	push32(val1);
}

macro select64() {
	local cond:4;
	pop32(cond);
	local val1:8;
	local val2:8;
	pop64(val2);
	pop64(val1);
	if (cond != 0) goto <true>;
	push64(val2);
	goto inst_next;
<true>
	push64(val1);
}

:""^indent^"select" is opc=0x1b; indent; ctx_is_op64=0 {
	select32();
}
:""^indent^"select" is opc=0x1b; indent; ctx_is_op64=1 {
	select64();
}
# In the current version of WASM, only one type index is permitted in select t*.
# This is functionally identical to regular select.

:""^indent^"select" is opc=0x1c; opc2=0x01; valtype; indent {
	# i64, f64, funcref, externref
	select64();
}
:""^indent^"select" 0x7f is opc=0x1c; opc2=0x01; valtype=0x7f; indent {
	# i32
	select32();
}
:""^indent^"select" 0x7d is opc=0x1c; opc2=0x01; valtype=0x7d; indent {
	# f32
	select32();
}

## Variable Instructions
:""^indent^"local.get" local4 is opc=0x20; local4; indent; ctx_is_op64=0 {
	push32(local4);
}
:""^indent^"local.get" local8 is opc=0x20; local8; indent; ctx_is_op64=1 {
	push64(local8);
}

:""^indent^"local.set" local4 is opc=0x21; local4; indent; ctx_is_op64=0 {
	pop32(local4);
}
:""^indent^"local.set" local8 is opc=0x21; local8; indent; ctx_is_op64=1 {
	pop64(local8);
}

:""^indent^"local.tee" local4 is opc=0x22; local4; indent; ctx_is_op64=0 {
	pop32(local4);
	push32(local4);
}
:""^indent^"local.tee" local8 is opc=0x22; local8; indent; ctx_is_op64=1 {
	pop64(local8);
	push64(local8);
}

:""^indent^"global.get" global4 is opc=0x23; global4; indent; ctx_is_op64=0 {
	push32(global4);
}
:""^indent^"global.get" global8 is opc=0x23; global8; indent; ctx_is_op64=1 {
	push64(global8);
}

:""^indent^"global.set" global4 is opc=0x24; global4; indent; ctx_is_op64=0 {
	pop32(global4);
}
:""^indent^"global.set" global8 is opc=0x24; global8; indent; ctx_is_op64=1 {
	pop64(global8);
}

## Table Instructions
:""^indent^"table.get" tableref is opc=0x25; tableref; indent {
	local idx:4;
	pop32(idx);
	addr:8 = &tableref + sext(idx) * 8;
	val:8 = *[table] addr;
	push64(val);
}

:""^indent^"table.set" tableref is opc=0x26; tableref; indent {
	local val:8;
	pop64(val);
	local idx:4;
	pop32(idx);
	addr:8 = &tableref + sext(idx) * 8;
	*[table] addr = val;
}

:""^indent^"table.init" elemidx tableidx is opc=0xfc; opc2=0x0c; elemidx; tableidx; indent {
	local count:4;
	pop32(count);
	local src:4;
	pop32(src);
	local dst:4;
	pop32(dst);
	table_init(elemidx:4, tableidx:4, count, src, dst);
}

:""^indent^"elem.drop" elemidx is opc=0xfc; opc2=0x0d; elemidx; indent {
	elem_drop(elemidx:4);
}

:""^indent^"table.copy" tableidx tableidx2 is opc=0xfc; opc2=0x0e; tableidx; tableidx2; indent {
	local count:4;
	pop32(count);
	local src:4;
	pop32(src);
	local dst:4;
	pop32(dst);
	table_copy(tableidx:4, tableidx2:4, count, src, dst);
}

:""^indent^"table.grow" tableidx is opc=0xfc; opc2=0x0f; tableidx; indent {
	local new_sz:4;
	pop32(new_sz);
	val:4 = table_grow(tableidx:4, new_sz);
	push32(val);
}

:""^indent^"table.size" tableidx is opc=0xfc; opc2=0x10; tableidx; indent {
	val:4 = table_size(tableidx:4);
	push32(val);
}

:""^indent^"table.fill" tableidx is opc=0xfc; opc2=0x11; tableidx; indent {
	local count:4;
	pop32(count);
	local val:8;
	pop64(val);
	local dst:4;
	pop32(dst);
	table_fill(tableidx:4, count, val, dst);
}


## Memory Instructions
:""^indent^"memory.size" memidx is opc=0x3f; memidx; indent {
	val:4 = memory_size(memidx:4);
	push32(val);
}

:""^indent^"memory.grow" memidx is opc=0x40; memidx; indent {
	local new_sz:4;
	pop32(new_sz);
	val:4 = memory_grow(memidx:4, new_sz);
	push32(val);
}

:""^indent^"memory.init" dataidx memidx is opc=0xfc; opc2=0x08; dataidx; memidx; indent {
	local count:4;
	pop32(count);
	local src:4;
	pop32(src);
	local dst:4;
	pop32(dst);
	memory_init(dataidx, memidx:4, count, src, dst);
}

:""^indent^"data.drop" dataidx is opc=0xfc; opc2=0x09; dataidx; indent {
	data_drop(dataidx);
}

:""^indent^"memory.copy" memidx memidx2 is opc=0xfc; opc2=0x0a; memidx; memidx2; indent {
	local count:4;
	pop32(count);
	local src:4;
	pop32(src);
	local dst:4;
	pop32(dst);
	memory_copy(memidx:4, memidx2:4, count, src, dst);
}

:""^indent^"memory.fill" memidx is opc=0xfc; opc2=0x0b; memidx; indent {
	local count:4;
	pop32(count);
	local val:4;
	pop32(val);
	local dst:4;
	pop32(dst);
	memory_fill(memidx:4, count, val, dst);
}

## Numeric Instructions: const
:""^indent^"i32.const" SLeb128 is opc=0x41; SLeb128; indent {
	val:4 = SLeb128:4;
	push32(val);
}

:""^indent^"i64.const" SLeb128 is opc=0x42; SLeb128; indent {
	val:8 = SLeb128:8;
	push64(val);
}

:""^indent^"f32.const" f32 is opc=0x43; f32; indent {
	val:4 = f32:4;
	push32(val);
}

:""^indent^"f64.const" f64 is opc=0x44; f64; indent {
	val:8 = f64:8;
	push64(val);
}

@include "BasicOps.sinc"
